---
title: "CulturalBechdel2"
author: "Anna"
date: "2024-11-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# install packages
install.packages("pacman")
install.packages("reshape2")
install.packages('brant')
pacman::p_load(tidyverse, readr, ggplot2, dplyr, tidyr, car, MASS, brant)

```
## Loading data
```{r}
## Load data
bechdel2_df <- read_csv("../data/Bechdel_IMDB_Merge0524.csv")

df_subset <- bechdel2_df %>% filter(year >=2011)
```
```{r}
# Plot number of films for each release year, see every 5 years on x-axis for each data set
df_subset %>%
  count(year) %>%
  ggplot(aes(x = year, y = n)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(title = "Number of films for each release year",
       x = "Release Year",
       y = "Count") +
  scale_x_continuous(breaks = seq(1900, 2020, by = 5))  # Show every 5 years on x-axis

```

```{r}
# Make table with no. of films with each rating value of 0-3
df_subset %>% 
  group_by(bechdelRating) %>% 
  summarise(count = n()) %>% 
  ggplot(aes(x = bechdelRating, y = count)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(title = "Number of films with each rating value",
       x = "Rating",
       y = "Count")
```
```{r}
# plot all genres
df_subset %>%
  gather(key = "genre_column", value = "genre_value", genre1:genre3) %>%  # Gather all genre columns
  filter(!is.na(genre_value)) %>%  # Remove rows where genre is NA
  count(genre_value, name = "Count") %>%  # Count occurrences of each genre
  ggplot(aes(x = reorder(genre_value, -Count), y = Count)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(title = "Number of films in each genre category",
       x = "Genre",
       y = "Count") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# plot only first genre
df_subset %>%
  count(genre1) %>%
  ggplot(aes(x = genre1, y = n)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(title = "Number of films in each genre category",
       x = "Genre",
       y = "Count") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# facetwrap by Bechdel rating
df_subset %>%
  gather(key = "genre_column", value = "genre_value", genre1:genre3) %>%  # Gather all genre columns
  filter(!is.na(genre_value)) %>%  # Remove rows where genre is NA
  count(bechdelRating, genre_value, name = "Count") %>%  # Count occurrences of each genre
  ggplot(aes(x = reorder(genre_value, -Count), y = Count)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(title = "Number of films in each genre category",
       x = "Genre",
       y = "Count") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~ bechdelRating ,ncol=1)  # Facet by Rating

```
```{r data cleaning}
# adding a before or after 2017 column
df_subset$after2017 <- ifelse(df_subset$year > 2017, 1, 0)

# encoding genre as one hot instead

# Reshape and one-hot encode genres
data_long <- df_subset %>%
  pivot_longer(cols = starts_with("genre"), names_to = "genre_type", values_to = "genre") %>% 
  dplyr::select(-genre_type)  # Remove unnecessary column

data_long <- melt(df_subset, id.vars = c("title", "bechdelRating", "year", "after2017"), 
                  measure.vars = c("genre1", "genre2", "genre3"),
                  variable.name = "genre_type", value.name = "genre")

data_wide <- dcast(data_long, title + bechdelRating + year + after2017 ~ genre, 
                      fun.aggregate = length, value.var = "genre")

# removing NA and backslash N column and News (only one movie has this genre)
data_wide <- data_wide %>% 
  dplyr::select(-c('NA', 5, 'News'))

# doing the same for data long (used for plotting)
data_long <- data_long %>% 
  filter(genre != "NA" & genre != "News")

data_long <- data_long[-1304, ] # because i could not remove the backlash N value in other ways

# renaming SciFi column
data_wide$SciFi <- data_wide$`Sci-Fi`

# doing the same for data long
data_long$genre <- gsub("-", "", data_long$genre)

```

```{r encoding year differently}
data_wide$year <- data_wide$year - 2011
```

Ordinal logistic regression
```{r}
data_wide$bechdelRating <- as.factor(data_wide$bechdelRating)
data_wide$after2017 <- as.factor(data_wide$after2017)

# Model
model5 <- polr(bechdelRating ~ after2017, data = data_wide, Hess = TRUE)
summary(model5)

# Predicted probabilities
predicted_probs <- predict(model5, type = "probs")
predicted_probs <- as.data.frame(predicted_probs) # make df
colnames(predicted_probs) <- levels(data_wide$bechdelRating) # Add column names to match category labels
 
# Add predictions to the original data
data_with_probs <- cbind(data_wide, predicted_probs)

# Reshape the dataset into long format
data_long_2 <- data_with_probs %>%
  pivot_longer(
    cols = all_of(levels(data_wide$bechdelRating)), # Columns for categories
    names_to = "bechdelCategory",                  # New column for category labels
    values_to = "probability"                      # New column for probabilities
  )


# Calculate P-values
model_summary <- summary(model5)

# Extract the coefficients, standard errors, and t-values
coefficients <- model_summary$coef[, "Value"]
standard_errors <- model_summary$coef[, "Std. Error"]
t_values <- model_summary$coef[, "t value"]

# Calculate p-values using the normal approximation
p_values <- 2 * pnorm(abs(t_values), lower.tail = FALSE)
# Print the p-values
print(p_values)

# Calculate confidence intervals (95%)
lower_bound <- coefficients - 1.96 * standard_errors
upper_bound <- coefficients + 1.96 * standard_errors

# Output the coefficients and p-values for easy interpretation
results_df <- data.frame(
  Coefficients = coefficients,
  StandardErrors = standard_errors,
  tValues = t_values,
  pValues = p_values,
  ci_lower = lower_bound,
  ci_upper = upper_bound
)

# Print the results
print(results_df)

```

```{r testing for the proportional odds assumption}
# Perform the Brant test: this is a test for the proportional odds assumption (which is that the relationship between the predictors and the log-odds of the response variable is constant across all thresholds)
brant_test <- brant(model5)

# Print the results: if p-value is HIGHER than 0.05, then we are good. 
print(brant_test)
```

```{r}
## Plot
ggplot(data_long_2, aes(x = after2017, y = probability, fill = bechdelCategory)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(
    title = "Predicted Probabilities of Bechdel Ratings",
    x = "Before and After 2017",
    y = "Probability",
    fill = "Bechdel Rating"
  ) +
  theme_minimal()


ggplot(data_long_2, aes(x = as.numeric(as.factor(after2017)), y = probability, color = bechdelCategory)) +
  geom_line(aes(group = bechdelCategory)) +
  geom_point() +
  scale_x_continuous(breaks = c(1, 2), labels = c("Before 2017", "After 2017")) +
  labs(
    title = "Predicted Probabilities of Bechdel Ratings",
    x = "Before and After 2017",
    y = "Probability",
    color = "Bechdel Rating"
  ) +
  theme_minimal()


```


Ordinal Logistic Regression with all genres
```{r}
model1 <- polr(bechdelRating ~ after2017 + Action + Adventure + Animation + Biography + Comedy + Crime + Documentary + Drama + Family + Fantasy + History + Horror + Music + Musical + Mystery + Romance + SciFi + Sport + Thriller + War + Western, data = data_wide)

summary(model1)
```
```{r}
# 1. Predicted Probabilities (model1)
# Generate predicted probabilities for all categories of 'bechdelRating'
predicted_probs_model1 <- predict(model1, type = "probs")

# Convert predicted probabilities to a data frame
predicted_probs_df <- as.data.frame(predicted_probs_model1)

# Assign the correct column names based on the levels of 'bechdelRating'
colnames(predicted_probs_df) <- levels(data_wide$bechdelRating)

# 2. Add predicted probabilities to the original dataset (without overwriting)
data_with_probs_model1 <- cbind(data_wide, predicted_probs_df)

# 3. Reshape the dataset into long format for visualization (without overwriting)
data_long_model1 <- data_with_probs_model1 %>%
  pivot_longer(
    cols = all_of(levels(data_wide$bechdelRating)),  # Columns for categories
    names_to = "bechdelCategory",                    # New column for category labels
    values_to = "probability"                        # New column for probabilities
  )

# 4. Calculate p-values for the new model (model1)
model1_summary <- summary(model1)

# Extract the coefficients, standard errors, and t-values
coefficients_model1 <- model1_summary$coef[, "Value"]
standard_errors_model1 <- model1_summary$coef[, "Std. Error"]
t_values_model1 <- model1_summary$coef[, "t value"]

# Calculate p-values using the normal approximation
p_values_model1 <- 2 * pnorm(abs(t_values_model1), lower.tail = FALSE)

# Print the p-values
print(p_values_model1)

# 5. Output the coefficients and p-values for easy interpretation
results_df_model1 <- data.frame(
  Coefficients = coefficients_model1,
  StandardErrors = standard_errors_model1,
  tValues = t_values_model1,
  pValues = p_values_model1
)

# Print the results
print(results_df_model1)

```
```{r interaction model}

# making two different to see which is best collinarity wise (chunk underneath)
model2 <- polr(bechdelRating ~ after2017 * (Action + Adventure + Animation + Biography + Comedy + Crime + Documentary + Drama + Family + Fantasy + History + Horror + Music + Musical + Mystery + Romance + SciFi + Sport + Thriller + War + Western), data = data_wide)

model3 <- polr(bechdelRating ~ after2017 : (Action + Adventure + Animation + Biography + Comedy + Crime + Documentary + Drama + Family + Fantasy + History + Horror + Music + Musical + Mystery + Romance + SciFi + Sport + Thriller + War + Western), data = data_wide)

```
```{r checking for multicollinearity between predictors}
vif(model2)
vif(model3)

# model 2 has wayy to much collinearity (after2017 especially), model3 looks good tho, lets check that output:

summary(model3)

```


```{r}
# Get significant genres

# 1. Get the summary of the model
model1_summary <- summary(model1)

# 2. Extract the coefficients, standard errors, t-values, and p-values for the model
coefficients_model1 <- model1_summary$coef[, "Value"]
standard_errors_model1 <- model1_summary$coef[, "Std. Error"]
t_values_model1 <- model1_summary$coef[, "t value"]
p_values_model1 <- 2 * pnorm(abs(t_values_model1), lower.tail = FALSE)

# 3. Create a data frame with coefficients, standard errors, t-values, and p-values
coefficients_df <- data.frame(
  Coefficients = coefficients_model1,
  StandardErrors = standard_errors_model1,
  tValues = t_values_model1,
  pValues = p_values_model1
)
# 4. Filter the coefficients corresponding to genres (excluding intercepts)
# Get the column names of the genre variables
genre_columns <- c("Action", "Adventure", "Animation", "Biography", "Comedy", 
                   "Crime", "Documentary", "Drama", "Family", "Fantasy", 
                   "History", "Horror", "Music", "Musical", "Mystery", 
                   "Romance", "SciFi", "Sport", "Thriller", "War", "Western")

# Subset only the genre-related coefficients and their p-values
genre_pvalues_df <- coefficients_df[rownames(coefficients_df) %in% genre_columns, ]

# 5. Filter to get genres with p-value < 0.05 (significant results)
significant_genres <- genre_pvalues_df[genre_pvalues_df$pValues < 0.05, ]

# 6. Print the significant genres
print(significant_genres)
```
# Plot

```{r}
sig_genres <- rownames(significant_genres)

# Filtrer data for kun de signifikante genrer
data_significant <- data_long %>%
  filter(genre %in% sig_genres)

ggplot(data_significant, aes(x = as.numeric(as.factor(after2017)), y = bechdelRating, group = genre, color = genre)) +
  geom_smooth(method = "lm", se = FALSE) +
  scale_x_continuous(breaks = c(1, 2), labels = c("Before 2017", "After 2017")) +
  labs(title = "Bechdel rating over time for Significant Genres",
       x = "Year",
       y = "Bechdel rating") +
  theme_minimal()


ggplot(data_significant, aes(x = as.numeric(as.factor(after2017)), y = bechdelRating, group = genre, color = genre)) +
  geom_smooth(method = "lm", se = TRUE) +
  scale_x_continuous(breaks = c(1, 2), labels = c("Before 2017", "After 2017")) +
  labs(title = "Bechdel rating over time for Significant Genres",
       x = "Year",
       y = "Bechdel rating") +
  theme_minimal()+
  facet_wrap(~genre)
```




OLD MODELS & PLOTS:


```{r}
ggplot(data_long, aes(x = after2017, y = bechdelRating)) +
  geom_smooth(method = "lm", se = TRUE) +
  labs(title = "Bechdel rating over time",
       x = "Year",
       y = "Bechdel rating") +
  facet_wrap(~genre)
```



```{r}
model0 <- lm(bechdelRating ~ after2017, data = data_wide)
summary(model0)
```
```{r}
ggplot(data_long, aes(x = after2017, y = bechdelRating)) +
  geom_smooth(method = "lm", se = TRUE, color = "dark red") +
  labs(title = "Increase in Bechdel rating after 2017",
       x = "Before and after 2017",
       y = "Bechdel rating") +
  theme_minimal(base_size = 14) + 
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.title = element_text(face = "italic"),
    axis.title.y = element_text(face = "italic"))
  

# husk at få ændret y aksen

```




```{r linear model}
# Linear model with all genres
model1 <- lm(bechdelRating ~ after2017 + Action + Adventure + Animation + Biography + Comedy + Crime + Documentary + Drama + Family + Fantasy + History + Horror + Music + Musical + Mystery + Romance + SciFi + Sport + Thriller + War + Western, data = data_wide)

summary(model1)

```

```{r}
significant_genres <- c("Action", "Biography", "Crime", "Documentary", "Romance", "SciFi", "Sport", "War", "Western")

# Filtrer data for kun de signifikante genrer
data_significant <- data_long %>%
  filter(genre %in% significant_genres)
```


